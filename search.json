[{"title":"ES6 - Array","date":"2017/04/08","path":"2017/04/08/es6-array/","text":"Array123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 遍历数组let arr = [1, 2, 5, 8]for(let i=0,len=arr.length; i&lt;len; i++) &#123; console.log(arr[i]) // 1 2 5 8&#125;for(let item of arr) &#123; console.log(item) // 1 2 5 8&#125;function sum() &#123; let args = Array.from(arguments) return args.reduce((prev, curr) =&gt; prev + curr)&#125;console.log(sum(1, 6, 9, 4))// 过滤let animal = [ &#123; type: 'dog', color: 'white' &#125;, &#123; type: 'dog', color: 'black' &#125;, &#123; type: 'cat', color: 'white' &#125;, &#123; type: 'cat', color: 'yellow' &#125;]let filterAnimal = animal.filter((animal) =&gt; animal.type === 'dog')console.log(filterAnimal)// somelet a = [2, 4, 5, 7]a.some((i) =&gt; console.log(i * 2)) // 4 8 10 14// 数组去重// ES5function unique(arr) &#123; return arr.filter((item, index, arr) =&gt; &#123; return arr.indexOf(item) === index &#125;)&#125;// ES6function unique2(arr) &#123; return [...new Set(arr)]&#125;","categories":[{"name":"js","slug":"js","permalink":"https://lencx.github.io/blog/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://lencx.github.io/blog/tags/ES6/"},{"name":"Array","slug":"Array","permalink":"https://lencx.github.io/blog/tags/Array/"}]},{"title":"ES6 - Object","date":"2017/04/08","path":"2017/04/08/es6-object/","text":"Object12345678910111213141516171819202122232425262728let a = &#123; height: 'a100', width: 'a200', size: 'a400'&#125;let b = &#123; height: 'b100', width: 'b300', weight: 'b500'&#125;let c = Object.assign(&#123;&#125;, a, b)console.log(c) // Object &#123;height: \"b100\", width: \"b300\", size: \"a400\", weight: \"b500\"&#125;let d = Object.assign(&#123;&#125;, b, a)console.log(d) // Object &#123;height: \"a100\", width: \"a200\", weight: \"b500\", size: \"a400\"&#125;// copylet person = &#123; name: 'len', age: 22&#125;// person2 = person// person2.age = 24// console.log(person) // Object &#123;name: \"len\", age: 24&#125;//let person2 = Object.assign(&#123;&#125;, person)//person2.age = 25let person2 = Object.assign(&#123;&#125;, person, &#123;age: 25&#125;)console.log(person, person2)// Object &#123;name: \"len\", age: 22&#125; Object &#123;name: \"len\", age: 25&#125;","categories":[{"name":"js","slug":"js","permalink":"https://lencx.github.io/blog/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://lencx.github.io/blog/tags/ES6/"},{"name":"Object","slug":"Object","permalink":"https://lencx.github.io/blog/tags/Object/"}]},{"title":"ES6-Promise","date":"2017/04/02","path":"2017/04/02/es6-promise/","text":"Promise Promise对象用于异步计算。承诺是Promise创建时不一定知道的值的代理，它允许你将处理程序与异步操作的最终成功的值或失败的原因相关联。异步方法返回一个承诺，以在将来的某个时间提供该值。 pending： 初始状态，未履行或拒绝 fulfilled： 操作成功完成 rejected： 操作失败 Properties 属性 Promise.length 长度属性始终为1（构造函数参数数量） Promise.prototype Promise构造函数的原型 Methods 方法 Promise.all(iterable) Promise.all()方法返回一个Promise，它在迭代参数中所有的Promise(承诺)都解决时解决，否则拒绝接受拒绝的第一个Promise(承诺) Fulfillment：如果所有的传递承诺都完成，Promsie.all()将按照在iterable中定义的顺序，从传入的承诺中获得一组数组值。如果传递一个空数组，该方法则立即解决。 Rejection：如果任何通过的承诺拒绝，Promsie.all()立即拒绝具有拒绝承诺的值，无论其他承诺是否已经解决。 12345678910111213141516171819202122232425262728293031// 等待所有的履行（或第一个拒绝）let p1 = Promise.resolve(123)let p2 = 'abc'let p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 1000, 'foo')&#125;)Promise.all([p1, p2, p3]).then(val =&gt; &#123; console.log(val) // [123, \"abc\", \"foo\"]&#125;)// 如果任何元素被拒绝，`Promise.all`立即拒绝。如果你通过超时后解决两个承诺和一个立即拒绝的承诺，那么`Promise.all`将立即拒绝。let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 500, 'a')&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 1000, 'b')&#125;)let p3 = new Promise((resolve, reject) =&gt; &#123; reject('reject')&#125;)Promise.all([p1, p2, p3]).then(val =&gt; &#123; console.log(val)&#125;, reason =&gt; &#123; console.log(reason) // reject&#125;)// 使用`catch`Promise.all([p1, p2, p3]).then(val =&gt; &#123; console.log(val)&#125;).catch(reason =&gt; &#123; console.log(reason) // reject&#125;) ⚠️ ： Promise.all([...]).then(val =&gt; {...}, reason =&gt; {...})与Promise.all([...]).then(val =&gt; {...}).catch(reason =&gt; {...})是两种写法。 Promise.race() Promise.race方法返回一个解决或拒绝的承诺，一旦该迭代中的一个承诺解决或拒绝，则返回。它解决或拒绝，以先发生者为准。 12345678910111213141516171819202122232425262728let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 800, 'a')&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 1000, 'b')&#125;)let p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 500, 'c')&#125;)let p4 = new Promise((resolve, reject) =&gt; &#123; setTimeout(reject, 700, 'd')&#125;)Promise.race([p1, p2, p3]).then(val =&gt; &#123; console.log(val) // c // `p1, p2, p3`都解决了，但`p3`最快&#125;)Promise.race([p3, p4]).then(val =&gt; &#123; console.log(val) // c // `p3`更快，所以解决了&#125;, reason =&gt; &#123; // Not called&#125;)Promise.race([p2, p4]).then(val =&gt; &#123; // Not called&#125;, reason =&gt; &#123; console.log(reason) // d // `p4`更快，所以拒绝&#125;) Promise.reject() Promise.reject(reason)方法返回一个由给定原因拒绝的Promise对象 12345Promise.reject(new Error('fail')).then(err = &#123; // not called&#125;, err =&gt; &#123; console.log(err) // Error: fail&#125;) Promise.resolve(value) 返回使用给定值解析的Promise对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 使用静态`Promise.resolve`方法Promise.resolve('success').then(val =&gt; &#123; console.log(val)&#125;, reason =&gt; &#123; // not called&#125;)// 解决数组Promise.resolve([1, 2, 3]).then(val =&gt; &#123; console.log(val[1]) // 2&#125;)// 解决另一个`Promise`let original = Promise.resolve(true)Promise.resolve(original).then(v =&gt; console.log(v)) // true// 解决可疑和抛出错误/// 对象let p1 = Promise.resolve(&#123; then: (resolve, reject) =&gt; resolve('fulfilled!')&#125;)console.log(p1 instanceof Promise) // truep1.then(v =&gt; &#123; console.log(v) // fulfilled!&#125;, e =&gt; &#123; // not called&#125;)// 回调之前抛出let thenable = &#123; then: resolve =&gt; &#123; throw new TypeError('Throwing') resolve('Resloving') &#125;&#125;Promise.resolve(thenable).then(v =&gt; &#123; // not called&#125;, e =&gt; &#123; console.log(e) // TypeError: Throwing&#125;)// 回调之后抛出let thenable = &#123; then: resolve =&gt; &#123; resolve('Resolving') throw new TypeError('Throwing') &#125;&#125;Promise.resolve(thenable).then(v =&gt; &#123; console.log(v) // Resolving&#125;, e =&gt; &#123; // not called&#125;)","categories":[{"name":"js","slug":"js","permalink":"https://lencx.github.io/blog/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://lencx.github.io/blog/tags/ES6/"},{"name":"Promise","slug":"Promise","permalink":"https://lencx.github.io/blog/tags/Promise/"}]},{"title":"ES6 - Destructuring","date":"2017/04/01","path":"2017/04/01/es6-destructuring/","text":"Destructuring 解构赋值语法可以将数组或对象中的数据提取到不同的变量中 12345678910111213let person = &#123; name: 'len', age: 24&#125;let &#123;age&#125; = personconsole.log(age) // 24let number = [1, 2, 3, 4]let [first, second, , fourth] = numberconsole.log(first, second, fourth) // 1 2 4let [a, b, ...theRest] = numberconsole.log(a, b, theRest) // 1 2 [3, 4] Array destructuring 数组解构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152let foo = ['a', 'b', 'c']let [one, two, three] = fooconsole.log(one, two, three) // 'a' 'b' 'c'// 赋值与声明分离let a, b[a, b] = [1, 2]console.log(a, b) // 1 2// 默认值let a, b, c[a = 3, b = 5, c] = [8]console.log(a, b, c) // 8 5 undefined// 交换变量let x = 3let y = 5;[x, y] = [y, x]console.log(x, y) // 5 3// 解构从函数返回的数组function foo() &#123; return [3, 5]&#125;let a, b[a, b] = foo()console.log(a, b) // 3 5// 忽略一些返回值function bar() &#123; return [1, 4, 7]&#125;let [a, , b] = bar()console.log(a, b) // 1 7/// 全部忽略[,,] = bar()// 将`rest`数组分配到一个变量let [a, ...b] = [3, 5, 7, 8]console.log(a) // 3console.log(b) // [5, 7, 8]/// b后加一个逗号会报错，`rest`必须为最后一个参数var [a, ...b,] = [3, 5, 7, 8]; // SyntaxError: Rest element must be last element in array// 从正则表达式匹配中抽取值let url = 'https://lencx.github.io/blog/tags/'let _url = /^(\\w+)\\:\\/\\/([^\\/]+)\\/(.*)$/.exec(url)console.log(_url) // [\"https://lencx.github.io/blog/tags/\", \"https\", \"lencx.github.io\", \"blog/tags/\", index: 0, input: \"https://lencx.github.io/blog/tags/\"]let [, protocol, fullhost, fullpath] = _urlconsole.log(protocol) // httpsconsole.log(fullhost) // lencx.github.ioconsole.log(fullpath) // blog/tags/ Object destructuring 对象解构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107let obj = &#123;a: 3, b: 'abc'&#125;let &#123;a, b&#125; = objconsole.log(a, b) // 3 \"abc\"// 对象解构赋值与声明分离let a, b(&#123;a, b&#125; = &#123;a: 2, b: 5&#125;) // Object &#123;a: 2, b: 5&#125;// 重新分配变量名let rename = &#123;a: 7, b: 'asd'&#125;let &#123;a: num, b: str&#125; = renameconsole.log(num) // 7console.log(str) // \"asd\"// 默认值let &#123;a = 2, b = 4&#125; = &#123;a: 6&#125;console.log(a) // 6console.log(b) // 4// ES5 设置函数参数的默认值function defVal(option) &#123; option = option === undefined ? &#123;&#125; : option let color = option.color === undefined ? '#fff' : option.color let background = option.background === undefined ? 'red' : option.background let xy = option.xy === undefined ? &#123;x: 10, y: 10&#125; : option.xy console.log(color, background, xy)&#125;defVal(&#123; color: 'yellow', xy: &#123;x: 20, y: 15&#125;&#125;) // yellow red Object &#123;x: 20, y: 15&#125;// ES2015function defVal(&#123;color='#fff', background='red', xy=&#123;x:10, y:10&#125;&#125;) &#123; console.log(color, background, xy)&#125;defVal(&#123; color: 'yellow', xy: &#123;x: 20, y: 15&#125;&#125;) // yellow red Object &#123;x: 20, y: 15&#125;// 嵌套对象和数组解构let post = &#123; title: 'ES6 - Destructuring', meta: [&#123; author: 'len', date: '2017-04-01', tag: 'es6' &#125;]&#125;let &#123;title, meta: [&#123;author, date, tag: metaTag&#125;]&#125; = postconsole.log(title) // ES6 - Destructuringconsole.log(author) // lenconsole.log(date) // 2017-04-01console.log(metaTag) // es6// 迭代和解构let posts = [ &#123; title: 'Git Basics', meta: &#123; date: '2017-03-20', tag: 'git' &#125; &#125;, &#123; title: 'Hexo-theme-lencx', meta: &#123; date: '2017-03-10', tag: 'hexo' &#125; &#125;, &#123; title: 'CSS clearfix', meta: &#123; date: '2016-05-20', tag: 'css' &#125; &#125;]for(let &#123;title: t, meta: &#123;date: d&#125;&#125; of posts) &#123; console.log(`title: $&#123;t&#125;, date: $&#123;d&#125;`)&#125;// title: Git Basics, date: 2017-03-20// title: Hexo-theme-lencx, date: 2017-03-10// title: CSS clearfix, date: 2016-05-20// 从作为函数参数传递的对象中拉出字段function postTitle(&#123;title&#125;) &#123; return title&#125;function authorIs(&#123;title, meta: &#123;author: a&#125;&#125;) &#123; console.log(`$&#123;title&#125;: author is $&#123;a&#125;`)&#125;let post = &#123; title: 'test post', meta: &#123; author: 'lencx', date: '2017-04' &#125;&#125;console.log(`post title is $&#123;postTitle(post)&#125;`) // post title is test postauthorIs(post) // test post: author is lencx// 计算对象属性名称和解构let key = 'a'let &#123;[key]: foo&#125; = &#123;a: 'bar'&#125;console.log(foo) // bar 注： 在使用对象字面解构赋值而不用声明的情况下，赋值语句中的()是必须语法。直接使用{a, b} = {a: 2, b: 5}不是有效的独立语法，会抛出错误。因为左侧的{a, b}会被认为是块而不是对象字面值。","categories":[{"name":"js","slug":"js","permalink":"https://lencx.github.io/blog/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://lencx.github.io/blog/tags/ES6/"},{"name":"Destructuring","slug":"Destructuring","permalink":"https://lencx.github.io/blog/tags/Destructuring/"}]},{"title":"ES6 - Arrow Function","date":"2017/03/31","path":"2017/03/31/es6-arrow-function/","text":"Arrow function 箭头函数表达式具有比函数表达式更短的语法，并且不绑定其自身的this，arguments，super或new.target。箭头函数表达式最适合于非方法函数，它们不能用于构造函数。 Shorter functions 函数较短 1234567891011121314151617181920212223242526272829303132333435let numbers = [2,3,4,5]// 常规写法numbers.forEach(function(n) &#123; console.log(n * 2)&#125;)// 箭头函数numbers.forEach(n =&gt; console.log(n * 2))// 当只有一个参数时，圆括号可省略，只有一条执行语句时，花括号也可省略let a = i =&gt; i// 等同于let a = function(i) &#123; return i&#125;// 当无参数或有多个参数时，就用圆括号代表参数部分let b = () =&gt; 123// 等同于let b = function() &#123; return 123&#125;let sum = (a, b) =&gt; a + b// 等同于let sum = function(a, b) &#123; return a + b&#125;// 当有多条执行语句时，则需使用花括号括起来let c = (a, b) =&gt; &#123; let m = a + b console.log(m)&#125;// 由于花括号会被解释为代码块，所以如果箭头函数直接返回一个对象，则必须在对象外加一个括号，否则会报错let obj = (name, age) =&gt; &#123;name: name, age: age&#125; // SyntaxError: Unexpected token :// 正确写法为let obj = (name, age) =&gt; (&#123;name: name, age: age&#125;) No binding of this 不绑定this: 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象 12345678910111213141516171819202122232425262728function Person() &#123; // 构造函数将`this`定义为自身的一个实例 this.age = 0 setInterval(function growUp() &#123; // console.log(this === window) // true // 此处的`this`指向`window` console.log(this.age++) // NaN &#125;, 1000)&#125;new Person()// 将`this`赋值给其他变量可解决该问题function Person() &#123; this.age = 0 let that = this setInterval(function growUp() &#123; console.log(that.age++) // 0, 1, 2, ... &#125;, 1000)&#125;new Person()// 使用箭头函数可以优雅的解决该问题function Person() &#123; this.age = 0 // 0, 1, 2, ... setInterval(() =&gt; console.log(this.age++), 1000)&#125;new Person() 123456789101112131415161718192021222324let person = &#123; name: 'len', say: function() &#123; console.log(this.name) &#125;&#125;person.say() // lenlet person = &#123; name: 'len', say: () =&gt; &#123; console.log(this.name) &#125;&#125;person.say() // 值为空，访问不到// 正确写法为let person = &#123; name: 'len', say() &#123; console.log(this.name) &#125;&#125;person.say() // len 12345678910111213141516171819202122232425let person = &#123; name: 'Len', hobbies: ['Computers', 'Music', 'Art'], showHobbies: function() &#123; this.hobbies.map(function(hobby) &#123; console.log(`$&#123;this.name&#125; likes $&#123;hobby&#125;`) &#125;) &#125;&#125;person.showHobbies()// Len likes Computers// Len likes Music// Len likes Art// 或者let person = &#123; name: 'Len', hobbies: ['Computers', 'Music', 'Art'], showHobbies() &#123; this.hobbies.map(hobby =&gt; &#123; console.log(`$&#123;this.name&#125; likes $&#123;hobby&#125;`) &#125;) &#125;&#125;person.showHobbies() No binding of arguments 不绑定参数：arguments对象在函数体内不存在 123456789// 使用箭头函数，获取参数报错let foo = () =&gt; console.log(arguments)foo(4, 5, 6) // ReferenceError: arguments is not defined at foo// 常规函数function bar() &#123; console.log(arguments)&#125;bar(1, 2, 4) // [1, 2, 4] ⚠️ ：箭头函数没有自己的arguments对象，不过在大多数情况下，rest参数可以给出一个解决方案12let foo = (...args) =&gt; console.log(args)foo(1, 3, 5, 7) // [1, 3, 5, 7] Rest parameters apply rest参数应用 1234567891011121314151617181920212223242526272829303132333435363738// 求和let sum = function() &#123; return Array.prototype.reduce.call(arguments, (prev, curr) =&gt; prev + curr)&#125;console.log(sum(2, 3, 5, 8)) // 18let sum = function(...args) &#123; return args.reduce((prev, curr) =&gt; prev + curr)&#125;console.log(sum(2, 3, 5, 8)) // 18// 乘法let multiply = (mul, ...num) =&gt; &#123; return num.map(n =&gt; mul * n)&#125;console.log(multiply(3, 2, 4, 5, 7)) // [6, 12, 15, 21]// 取最大值let max = Math.max(4, 7, 5, 6)console.log(max) // 7// 直接使用变量，获取的值为`NaN`let numbers = [3, 5, 8, 6]let max = Math.max(numbers)console.log(max) // NaN// 解决办法let max = Math.max.apply(null, numbers)console.log(max) // 8// 使用`rest`参数更简便let numbers = [3, 5, 8, 6]let max = Math.max(...numbers)console.log(max) // 8// 数组的连接let arr = [3, 5, 7, 9]let newArr = [2, 4, 6, 8]let concatArr = newArr.concat(arr) // [2, 4, 6, 8, 3, 5, 7, 9]// 使用`rest`参数，直接在需要连接的数组后加入`rest`即可let newArr = [2, 4, 6, 8, ...arr] Arrow functions used as methods 箭头函数用作方法：箭头函数表达式最适合于非方法函数，当用作方法时会发生如下情况。 123456789let obj = &#123; x: 5, a: () =&gt; console.log(this.x, this), b: function() &#123; console.log(this.x, this) &#125;&#125;obj.a() // undefined | Windowobj.b() // 5 | Object &#123;...&#125; Use of the new operator 不能用作构造函数，与new一起使用时会报错 12let Person = () =&gt; &#123;&#125;new Person() // TypeError: Person is not a constructor at Use of prototype property 箭头函数无原型属性 1234let foo = () =&gt; &#123;&#125;console.log(foo.prototype) // undefinedlet bar = function() &#123;&#125;console.log(bar.prototype) // Object &#123;...&#125; Use of the yield keyword yield关键字通常不能在箭头函数中使用（除非在其中嵌套的函数允许），因此，箭头函数不能用作Generator函数。 Function bodyReturning object literals 返回对象：在使用箭头函数直接返回对象时会报错，直接返回对象时需用圆括号括起来 12let foo = () =&gt; &#123;name: 'len', age: 24&#125; // SyntaxError: Unexpected token :let foo = () =&gt; (&#123;name: 'len', age: 24&#125;) Line breaks 换行会报错 12let foo = () =&gt; 1 // SyntaxError: Unexpected token =&gt; Parsing order 解析顺序 1234let a, b, ca = a || function() &#123;&#125; // okb = b || () =&gt; &#123;&#125; // SyntaxError: invalid arrow-function argumentsc = c || (() =&gt; &#123;&#125;) // ok","categories":[{"name":"js","slug":"js","permalink":"https://lencx.github.io/blog/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://lencx.github.io/blog/tags/ES6/"},{"name":"function","slug":"function","permalink":"https://lencx.github.io/blog/tags/function/"}]},{"title":"ES6 - Variable and Template Literals","date":"2017/03/30","path":"2017/03/30/es6-variable/","text":"let let：声明块范围内的局部变量var：关键字声明的为全局变量，或者与整个函数本地定义，而与块范围无关 在ES5中只有全局作用域和函数作用域，而没有块级作用域，而let的特性则为JavaScript提供了块级作用域的功能，避免了变量泄漏。 Scoping rules 范围界定规则 12345678910111213141516171819202122232425// varfor(var i=0; i&lt;5; i++) &#123; console.log(i)&#125;console.log('outside loop:', i) // outside loop: 5// letfor(let i=0; i&lt;5; i++) &#123; console.log(i)&#125;console.log('outside loop:', i) // ReferenceError: i is not defined// let声明的变量在代码块外显示未定义&#123; var a = 1 let b = 2&#125;console.log(a) // 1console.log(b) // ReferenceError: b is not defined// 在程序和函数的顶层，let与var不同，不会在全局对象上创建一个属性var x = 10let y = 10console.log(this.x) // 10 // this =&gt; windowconsole.log(this.y) // undefined 在for循环中的用var声明的i变量在循环结束本该被销毁，但之后仍可被访问。替换为let时则会报错。在同一个代码块中同时声明a, b两个变量，在代码块外部a可以正常访问，用let声明b变量会报错。由此可以看出var声明的变量为全局变量，而let声明的变量只在所属的代码块内有效，只在本代码块之内有效，则说明let声明变量的代码块就是一个块级作用域。 Cleaner code in inner functions 在函数内部清洁代码 1234567891011121314151617181920let body = document.bodyfor(let i=0; i&lt;5; i++) &#123; let btn = document.createElement('button') btn.appendChild(document.createTextNode(`button $&#123;i&#125;`)) btn.onclick = e =&gt; &#123; console.log(`button $&#123;i&#125; is clicked!`) &#125; body.appendChild(btn)&#125;// 实现与let一样的功能，则必须创建一个不同的上下文，然后通过闭包来保存值for(var i=0; i&lt;5; i++) &#123; var btn = document.createElement('button') btn.appendChild(document.createTextNode(`button $&#123;i&#125;`)) ;(function(i) &#123; btn.onclick = function(e) &#123; console.log(`button $&#123;i&#125; is clicked!`) &#125; &#125;)(i) body.appendChild(btn)&#125; ⚠️ ：上面的代码之所以能按照预期的方式进行工作，是因为内部函数（匿名）的五个实例引用了变量i的五个不同实例。如果将let替换为var，则将无法工作，所有的内部函数都将返回i的最终值5。 Emulating private members 模拟私有成员：在处理构造函数时，可以通过使用闭包来使let语句来共享一个或多个私有成员。 123456789101112131415161718var SomeConstructor&#123; let privateScope = &#123;&#125; SomeConstructor = function someConstructor() &#123; this.someProperty = 'foo' privateScope.hiddenProperty = 'bar' &#125; SomeConstructor.prototype.showPublic = function() &#123; console.log(this.someProperty) // foo &#125; SomeConstructor.prototype.showPrivate = function() &#123; console.log(privateScope.hiddenProperty) // bar &#125;&#125;var instance = new SomeConstructor()instance.showPublic() // fooinstance.showPrivate() // barconsole.log(privateScope.hiddenProperty) // ReferenceError: privateScope is not defined ⚠️ ： 这种技术只提供“静态”私有状态，SomeConstructor的所有实例都将共享相同的privateScope。 Temporal dead zone and errors 暂时死区和错误 1234567891011121314151617// 重复声明会报错if(true) &#123; let a let a // SyntaxError: Identifier 'a' has already been declared&#125;// 声明的变量名与函数参数相同，会报错function foo(ags) &#123; let ags = 1 // SyntaxError: Identifier 'ags' has already been declared&#125;// 在变量声明之前引用，会报错function doSomething() &#123; console.log(a) let a = 1&#125;doSomething() // ReferenceError: a is not defined Other12345678910var a = 1var b = 2if(a === 1) &#123; var a = 5 let b = 8 console.log('a:', a) // a:5 // 范围是全局 console.log('b:', b) // b:8 // 范围是在if块内&#125;console.log('a:', a) // a:5console.log('b:', b) // b:2 const 常量：与let类似，也是块范围的，只是声明的变量值不能改变 12345678910const API_KEY = 'sahtkdfjkjehfudiurhtbnuwxm'console.log(API_KEY) // sahtkdfjkjehfudiurhtbnuwxmAPI_KEY = 'I changed API_KEY !'console.log(API_KEY) // TypeError: Assignment to constant variable.// 块范围if(true) &#123; const a=10&#125;console.log(a) // ReferenceError: a is not defined Template Literals 模板文字: 允许嵌入表达式的字符串文字，在ES5规范的先前版本中被称为模板字符串。 12345678910let Person = &#123; firstName: 'Len', lastName: 'C', sayName() &#123; // return 'My name is ' + firstName + ' ' + lastName + '.' return `My name is $&#123;this.firstName&#125; $&#123;this.lastName&#125;.` &#125;&#125;let sayname = Person.sayName()console.log(sayname) // My name is Len C. Multi-line strings 多行字符串：使用正常的字符串你需要加入\\n才能进行换行，而使用 ` ` 你只需正常的进行换行即可。 123456console.log('string text line 1\\n' + 'string text line 2')// string text line 1// string text line 2console.log(`string text line 3string text line 4`) Expression interpolation 表达式插值 1234567891011let a = 3let b = 4// 在正常字符串中嵌入表达式console.log('a + b = ' + (a + b) + ' \\nand\\na * b = ' + (a * b))// a + b = 7 // and// a * b = 12// 使用模板文字嵌入表达式console.log(`a + b = $&#123;a + b&#125;anda * b = $&#123;a * b&#125;`) Tagged template literals 标签模板 123456789101112131415161718function tpl(string, ...keys) &#123; return (...vals) =&gt; &#123; let dict = vals[vals.length - 1] || &#123;&#125; let result = [string[0]] keys.forEach((key, i) =&gt; &#123; let val = Number.isInteger(key) ? vals[key] : dict[key] result.push(val, string[i+1]) &#125;) return result.join('') &#125;&#125;let s1 = tpl`$&#123;0&#125;$&#123;2&#125;$&#123;1&#125;`console.log(s1('l','n','e')) // lenlet s2 = tpl`$&#123;0&#125;$&#123;'name'&#125;`console.log(s2('hello,', &#123;name: 'len'&#125;)) // hello,len// alert(1)alert`1` Raw string 原始字符串：标签模板文字的第一个函数参数可用的特殊属性允许你在输入时访问原始字符串，而无需处理转义序列。String.raw 12345function tag(str) &#123; return str.raw[0]&#125;// String.raw`123\\nabc`tag`123\\nabc` // 123\\nabc","categories":[{"name":"js","slug":"js","permalink":"https://lencx.github.io/blog/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://lencx.github.io/blog/tags/ES6/"},{"name":"variable","slug":"variable","permalink":"https://lencx.github.io/blog/tags/variable/"}]},{"title":"JS Console","date":"2017/03/25","path":"2017/03/25/js-console/","text":"log(), info()123console.log('a')// 可接受多个参数console.log('a', 'b', 1, 2) 占位符 占位符 符号 字符 %s CSS %c 整数 %d / %i 浮点数 %f 对象 %o ⚠️：不同格式数据必须使用对应格式的占位符 12345// %sconsole.log('%s + %s = %s', 2, 3, 6) // 2 + 3 = 6console.log('%s is red', '#f00') // #f00 is red// %cconsole.log('%chello, world', 'color:blue;background:yellow;font-size:36px;') group()1console.group(); warn(), error()1234// 警告console.warn()// 出错console.error()","categories":[{"name":"js","slug":"js","permalink":"https://lencx.github.io/blog/categories/js/"}],"tags":[{"name":"Tricks","slug":"Tricks","permalink":"https://lencx.github.io/blog/tags/Tricks/"},{"name":"console","slug":"console","permalink":"https://lencx.github.io/blog/tags/console/"}]},{"title":"Mac command","date":"2017/03/24","path":"2017/03/24/command/","text":"123456789101112131415161718192021222324252627# cd\\ # 直接返回到用户根路径cd# ls -a 查看隐藏文件ls# 创建文件touch &lt;filename&gt;# 删除文件rm -rf# 重命名文件mv &lt;old filename&gt; &lt;new filename&gt;# 文件追加内容# echo \"msg\" &gt;&gt; &lt;filename&gt;echo# used to format and display the man pagesman# 查看文件内容cat &lt;filename&gt;# 列出mac下所有的shell类型## /bin/bash /bin/csh /bin/ksh /bin/sh /bin/tcsh /bin/zshls /bin/*## 当前使用的shell类型echo $SHELL# 选择shell类型chsh -s /bin/zsh$(which /bin/bash)# 当前路径pwd","categories":[{"name":"bash","slug":"bash","permalink":"https://lencx.github.io/blog/categories/bash/"}],"tags":[{"name":"command","slug":"command","permalink":"https://lencx.github.io/blog/tags/command/"}]},{"title":"Git Basics","date":"2017/03/24","path":"2017/03/24/git-basics/","text":"File status lifecycle 文件状态的生命周期 Basics command 基础命令 1234567891011121314151617181920212223242526272829# Getting startedgit config --global user.name \"your name\"git config --global user.email \"your@email\"# initializes a directory as a git repositorygit init# view the status of your files in the working directory and staging areagit status# adds file contents to the staging area## git add -A## or ## git add .git add# shows diff of what is staged and what is modified but unstaged## git diff --staged # 查看暂存区变化git diff# records a snapshot of the staging area# git commit -m \"msg\"git commit# add &amp; commit 合二为一， 前提是必须正常提交过一次才能使用git commit -a -m \"msg\"# remove files from the staging area## git rm &lt;file name&gt; # 从暂存区将文件移除git rm# git rm --cached orig; mv orig new; git add new## git mv &lt;old filename&gt; &lt;new filename&gt; # staging area changedgit mv# show commit history of a branchgit log Working with remotes 远端 123456789101112# copy a git repositorygit clone URL# list, add and delete remote repository aliasesgit remote# download new brabches and data from a remote repositorygit fetch# merge a bash context into your current onegit merge# fetch from a remote repo and try to merge into the current branchgit pull# push your new branches and data to a remote repositorygit push Taging 标签 1234567891011121314151617# listing tagsgit tag# create taggit tag -a v1.0 -m \"my version 1.0\"# showing tag data along with commitgit show v1.0# tagging latergit tag -a v0.9 -m \"version 0.9\" [commit]# sharing tagsgit push origin [tagname]# If you have a lot of tags that you want to push up at once.# 一次推送多个taggit push origin --tags# delete local taggit tag -d [tagname]# delete origin taggit push origin :refs/tags/[tagname] Git configuration file git配置文件： ~/.gitconfig(or ~/.config/git/config) user[用户] alias[别名] core.editor[核心编辑器] 12345678910111213[user] name = Len email = cxin1314@gmail.com[alias] st = status ci = commit co = checkout br = branch df = diff lg = log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit last = log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit -1 HEAD[core] editor = emacs Snapshot git 是基于快照的，即文件改变，将该文件全部进行保存，blob改变，该文件所属的目录tree也改变tree: 目录(dir)blob: 文件(file) 12cd .git/objectsgit cat-file -p &lt;SHA-1&gt; 从以上的操作可以总结出如下的结论： Branch 分支创建与删除只需要将master文件中的内容重新复制到新文件中，即创建了一条新的分支，删除分支只需删除该文件即可。分支切换原理：修改HEAD文件 12345678910111213141516171819202122232425262728# list, create and delete branchesgit branch -## delete branchgit branch -d [branchname]## forced to deletegit branch -D [branchname]# switch to a new branch contextgit checkout -## create and switch branchgit checkout -b [branchname]# tracking remote branchesgit checkout --track origin/serverfixgit checkout -b sf origin/serverfix# merge a branch context into your current onegit merge# fast-forward merge# fix conflictgit rebase master [branchname]git checkout mastergit merge [branchname]git branch --mergedgit branch --no-mergedgit rebase --continue# apply the changes introduced by some existing commits## git cherry-pick [commit]git cherry-pick - Undoing Things 撤销⚠️： git checkout -- is dangerous. May be git stash is better.$ git stash apply .gitignore git 忽略文件及目录12345*~.DS_Store.idea.vscode/node_modules","categories":[{"name":"git","slug":"git","permalink":"https://lencx.github.io/blog/categories/git/"}],"tags":[{"name":"Tricks","slug":"Tricks","permalink":"https://lencx.github.io/blog/tags/Tricks/"},{"name":"command","slug":"command","permalink":"https://lencx.github.io/blog/tags/command/"},{"name":"git","slug":"git","permalink":"https://lencx.github.io/blog/tags/git/"}]},{"title":"hexo常见问题汇总","date":"2017/03/22","path":"2017/03/22/hexo-post/","text":"写作12345# 创建一篇文章# hexo new post &lt;your-post-title&gt;hexo new &lt;your-post-title&gt;# 创建一个页面hexo new page &lt;your-page-name&gt; 常用命令12345hexo init # 初始化hexo clean # 删除生成的文件和缓存hexo g # 生成静态文件hexo s # 启动服务，可以在本地预览hexo d # 部署 git部署1234567# 如果未安装hexo-deployer-gitnpm install hexo-deployer-git --save# 从远端克隆 .deploy_git 目录git clone &lt;gh-pages repo&gt; .deploy_git# 删除 .deploy_gitrm -rf .deploy_git 1234deploy: type: git repo: &lt;repository url&gt; branch: [branch] #master","categories":[{"name":"hexo","slug":"hexo","permalink":"https://lencx.github.io/blog/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://lencx.github.io/blog/tags/hexo/"}]},{"title":"hexo-theme-lencx","date":"2017/03/20","path":"2017/03/20/hexo-theme-lencx/","text":"Description 描述 本主题使用pug[jade], sass编写，可用webpack对css，js进行压缩。之所以选择pug是因为觉得这种模板语法很优雅（用缩进表示DOM结构，很简洁, 逻辑采用js的语法，作为前端表示无压力， include, block, mixins etc. 用起来也很方便。 具体语法可以参考Pug API，Sass API）。本主题支持响应式，未借助第三方库，如想使用栅格系统，在／source/css/part/_grid.scss中有一个简易版的bootstrap栅格,未build的scss源文件文件可参考bs-grid。或者使用postcss的插件库lost, postcss-cssnext etc. 进行编写。了解更多信息，请参考postcss。 Install plugins 使用本主题需要安装的依赖, 在根目录进行安装 1npm install hexo-renderer-pug hexo-renderer-sass --save Create categories, tags and about page 创建分类页与标签页123456# categories页面hexo new page categories# tags页面hexo new page tags# about页面hexo new page about ⚠️ ： categories与tags页面创建后无需编辑 主题设置及特性（Theme Setting and Features）Navigation(menu) 菜单 窗口宽度小于768px时，菜单折叠 当垂直滚动超过500px时，header会在一秒内消失。回滚时又在800ms内显示出来（呃，你若问我八百毫秒什么概念，我也不知道，自己滚滚就知道了。重在体验…😉 ） Archives 归档页 点击年份可折叠, 月份左上角显示本月文章数量⚠️ ：比较重要的一条，想要实现我图中的一长条不间断的显示，而不产生分页。请将根目录中_config.yml的 archive_generator: per_page值设大一点，为了免去麻烦，省的哪天再超了，我一次性设置了10000，虽然我这辈子都写不出来这么多，哈哈，就是任性。你要是不想任性，可以先设个几百条。 12archive_generator: per_page: 10000 关闭状态 打开状态 Categories 分类页 稀松平常，没啥好说的，本主题大量使用了文本阴影效果，不知会不会适得其反 🤔 。 Tags 标签页 偷偷告诉你，不光是这里的标签，在文章中的标签同样可以改变颜色， 角度啥的。（若不信，多刷新几次浏览器 😜 ）⚠️ ：这里同样有一个设置，不过不是针对menu中的tags设定的，而是从sidebar中的tagCloud点击跳转过来的当前tag的显示数量。值写小了，无外乎就是一个标签多分几页，看个人喜好，自行设定。此配置也是在根目录下的_config.yml文件中进行设置。 12tag_generator: per_page: 20 random box shadow random border-radius random font color random vertical position 随机1 随机2 Back To Top 回到顶部按钮 当垂直滚动超过300px时，按钮出现。小于300px消失 Posts List 首页文章列表 每页显示的文章数，需在根目录中的/_config.yml中进行设置123# Pagination## Set per_page to 0 to disable paginationper_page: 8 Sidebar 侧栏 窗口宽度小于992px，侧栏隐藏 与sidebar有关的配置项，文件路径/theme/_config.yml 1234567891011121314151617sidebar: tagCloud: # 是否开启标签云 enable: true # 是否开启背景（可用图片或直接设置背景色） bgEnable: true # bg: '#000' # '/blog' 是项目的根路径 默认跟路径是'／'，具体是啥请看根目录中_config.yml的root配置项 bg: url('/blog/img/bg-1.png') # 是否开启归档 archives: true # 是否开启分类 categories: true # 最新文章 recent_posts: enable: true # 是否开启 num: 5 # 条数 Tags Cloud canvas random font color 注：如需更改字体颜色，只能改源码了，我将随机色写入压缩后的js文件中，即/theme/hexo-theme-lencx/libs/tagcanvas.min.js font family, background color, text shadow etc. 可以在/theme/hexo-theme-lencxs/libs/tagcloud.js中更改 当然没事也可以换换背景啥的，也是👌 的。 Archives 锚点 点击某个月份链接跳转后定位到该月（该年份文章比较多时，此功能还比较实用 👍 ） 点击年份可折叠 一长坨看着就不舒服 ……^_^ 括号中数字为该月的文章数 Categories 呃， 貌似没啥说的。😳 Recent posts 最新文章 默认展示最新的5篇，可以在/theme/_config.yml中重新进行设定 Post Style 所有配置都在/theme/_config.yml中 Post meta 12345678# widget (文章小部件)# true 开启# false 关闭postMeta: author: true # 作者 date: true # 日期 tags: true # 标签 category: true # 分类 Code theme 点击代码块右上角的theme[white|black]可看到效果 Post toc click toc title [folding | open] title setting123post: # 文章目录标题文字设置 toc_title: CONTENT Read more 123post: # 阅读全文文字设置 excerpt_link: Read More Comment 评论 DISQUS 国内可能无法访问，如果使用该评论插件，我在main.js文件中做了一次判断，在3s内如果未加载，则显示Disqus due to network reasons, can not be loaded.，如果是因为网速不好，在大于3s后加载了，显示上可能会出现点小问题，但是如果是在10s内加载的，显示的问题还是会被移除掉。由于暂时没想到好的解决办法，该bug目前只能先这样，以后有好的办法再解决。但是如果不考虑网速问题。这个判断还是没什么问题的。即在3s内无法加载，则显示Disqus due to network reasons, can not be loaded.，否则正常加载Disqus 12disqus: disqus_shortname: lencx Theme Config 主题配色在/source/css/_theme.color.scss文件中几乎包含了该主题的所有颜色变量（background, color, box-shadow, text-shadow）,在／source/css/variable／_mixin.scss文件中的@mixin radius 参数$radius-enble值为true时启用所有的圆角，false则关闭。 Analytics 流量分析 Google Analytics12analytics: google_analytics: # your Google AnalyticsId Social 社区帐号123456social: github: your@github email: your@email.com facebook: your@facebook.com twitter: your@twitter.com stact_overflow: RSS RSS订阅 在根目录下安装1npm i hexo-generator-feed --save 12345678# https://github.com/hexojs/hexo-generator-feedfeed: type: atom path: atom.xml # 0/false[all] | number limit: false # hub: content: true Keywords &amp;&amp; Description 关键字及描述 在 root _config.yml中的description为网站描述 post中的描述及关键字则需要自己在模版中进行添加，模板路径为/scaffolds／post.md,多个关键字用半角英文逗号隔开，如果未使用keywords，默认将tags填充为关键字 Local Search 本地搜索：检索到的关键词高亮，不支持多词搜索优先级：标题 &gt; 标签 &gt; 内容12# generator content.json or search.jsonnpm i hexo-generator-json-content --save root _config.yml123456789101112131415161718192021jsonContent: meta: false keywords: false # language name option dateFormat: YYYY/MM/DD # format string posts: title: true tags: true path: true date: true text: true slug: false updated: false comments: false link: false permalink: false excerpt: false keywords: false # but only if root keywords option language was set # raw: false content: false categories: false pages: false Summary 结束语 还有很多细节上的处理就只能靠自己慢慢发现了。hexo-theme-lencx，本人会长期进行维护，哪天看着哪里不合眼了，还会修修补补，亦或大刀阔斧也说不准。 加点新鲜的，好玩的东东。时间有点仓促，还有很多功能还未添加，以后都会慢慢的加进来。","categories":[{"name":"hexo","slug":"hexo","permalink":"https://lencx.github.io/blog/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://lencx.github.io/blog/tags/hexo/"},{"name":"theme","slug":"theme","permalink":"https://lencx.github.io/blog/tags/theme/"}]},{"title":"CSS之清除浮动","date":"2016/05/04","path":"2016/05/04/css-clearfix/","text":"给元素设置浮动属性会使元素漂浮于普通文本流之上，导致元素内部不存在其他普通流元素，表现出的高度为0（高度塌陷，如果外层元素未给出具体高度，这时的盒子模型是不能自动计算出内部元素的实际高度）。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;style&gt;#wrap&#123; background: red; color: #ff3600;&#125;#wrap div&#123; width: 400px; background: green; margin: 5px; float: left;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"wrap\" class=\"clearfix\"&gt; &lt;div class=\"div1\"&gt;我是浮动div1&lt;/div&gt; &lt;div class=\"div2\"&gt;我是浮动div2&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在id=&quot;wrap&quot;的div中的末尾添加额外的标签如div，br，其他标签也可以，但必须是块级元素（两种方式）。 12345&lt;!--使用div标签与其自身的html属性--&gt;&lt;div style=\"clear: both\"&gt;&lt;/div&gt;&lt;!--使用br标签与其自身的html属性--&gt;&lt;br clear=\"all\"/&gt; 在id=&quot;wrap&quot;的div属性中添加属性（两种方式）。 123456789/* 父元素添加float,使其脱离普通文本流，盒子模型能够计算其实际的高度（不推荐使用）。 */#wrap&#123; float: left;&#125;/* 父元素添加overflow */#wrap&#123; overflow: hidden;&#125; 闭合浮动（闭合浮动原理——自行了解 hasLayout 和 Block formatting contexts） 12345678910111213141516171819202122232425.clearfix:after&#123; content: \".\"; display: block; visibility: hidden; height: 0; clear: both;&#125;/* 改进后的版本 */.clearfix:after&#123; content: \"200B\"; display: block; height: 0; clear: both;&#125;/* 或者 */.clearfix:after&#123; content: \"\"; display: table; clear: both;&#125;.clearfix&#123; zoom: 1; /*IE6/IE7*/&#125; sass &amp; postcss 123456789101112/// placeholder: sass占位符/// usage: @extend %clear-fix; %clearfix &#123; &amp;:after &#123; content: ''; display: table; clear: both; zoom: 1; &#125;&#125;/// postcss lostlost-utility: clearfix; 注：这是之前写的一篇，之前的博客被我全部删掉了，现在重新开始。时间还是使用之前的创建时间，特此说明。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://lencx.github.io/blog/categories/CSS/"}],"tags":[{"name":"clearfix","slug":"clearfix","permalink":"https://lencx.github.io/blog/tags/clearfix/"},{"name":"Tricks","slug":"Tricks","permalink":"https://lencx.github.io/blog/tags/Tricks/"}]}]